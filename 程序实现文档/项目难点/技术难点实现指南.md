# 健康管理系统技术难点实现指南

## 1. 图片上传与MinIO存储全链路实现

### 1.1 MinIO环境搭建

#### 1.1.1 Docker部署MinIO
```bash
# 创建MinIO数据目录
mkdir -p /data/minio/data
mkdir -p /data/minio/config

# 使用Docker运行MinIO
docker run -d \
  --name minio \
  -p 9000:9000 \
  -p 9001:9001 \
  -e "MINIO_ROOT_USER=minioadmin" \
  -e "MINIO_ROOT_PASSWORD=minioadmin123" \
  -v /data/minio/data:/data \
  -v /data/minio/config:/root/.minio \
  quay.io/minio/minio server /data --console-address ":9001"

# 验证MinIO启动
curl http://localhost:9000/minio/health/live
```

#### 1.1.2 MinIO客户端配置
```bash
# 安装MinIO客户端
wget https://dl.min.io/client/mc/release/linux-amd64/mc
chmod +x mc
sudo mv mc /usr/local/bin/

# 配置MinIO客户端
mc alias set local http://localhost:9000 minioadmin minioadmin123

# 创建存储桶
mc mb local/health-images
mc mb local/user-avatars

# 设置桶策略（公共读取）
mc policy set public local/health-images
mc policy set public local/user-avatars
```

### 1.2 后端MinIO集成实现

#### 1.2.1 安装依赖包
```bash
# 安装MinIO和文件处理相关依赖
npm install minio multer sharp uuid
npm install -D @types/multer @types/sharp
```

#### 1.2.2 MinIO配置文件
```typescript
// src/config/minio.ts
import { Client } from 'minio';
import dotenv from 'dotenv';

dotenv.config();

export const minioClient = new Client({
  endPoint: process.env.MINIO_ENDPOINT || 'localhost',
  port: parseInt(process.env.MINIO_PORT || '9000'),
  useSSL: process.env.MINIO_USE_SSL === 'true',
  accessKey: process.env.MINIO_ACCESS_KEY || 'minioadmin',
  secretKey: process.env.MINIO_SECRET_KEY || 'minioadmin123'
});

// 存储桶配置
export const BUCKETS = {
  USER_AVATARS: 'user-avatars',
  FOOD_IMAGES: 'food-images',
  HEALTH_IMAGES: 'health-images'
};

// 初始化存储桶
export const initializeBuckets = async (): Promise<void> => {
  try {
    for (const bucketName of Object.values(BUCKETS)) {
      const exists = await minioClient.bucketExists(bucketName);
      if (!exists) {
        await minioClient.makeBucket(bucketName, 'us-east-1');
        console.log(`✅ 创建存储桶: ${bucketName}`);

        // 设置公共读取策略
        const policy = {
          Version: '2012-10-17',
          Statement: [
            {
              Effect: 'Allow',
              Principal: { AWS: ['*'] },
              Action: ['s3:GetObject'],
              Resource: [`arn:aws:s3:::${bucketName}/*`]
            }
          ]
        };
        await minioClient.setBucketPolicy(bucketName, JSON.stringify(policy));
        console.log(`✅ 设置存储桶策略: ${bucketName}`);
      }
    }
  } catch (error) {
    console.error('❌ MinIO初始化失败:', error);
    throw error;
  }
};
```

#### 1.2.3 文件上传服务
```typescript
// src/services/uploadService.ts
import { Request } from 'express';
import multer from 'multer';
import sharp from 'sharp';
import { v4 as uuidv4 } from 'uuid';
import path from 'path';
import { minioClient, BUCKETS } from '../config/minio';

// 文件类型配置
const ALLOWED_IMAGE_TYPES = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];
const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB

// Multer配置（内存存储）
const upload = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: MAX_FILE_SIZE
  },
  fileFilter: (req: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
    if (!ALLOWED_IMAGE_TYPES.includes(file.mimetype)) {
      return cb(new Error('只支持 JPEG, PNG, WebP 格式的图片'));
    }
    cb(null, true);
  }
});

// 图片处理和上传服务类
export class UploadService {
  // 上传头像
  static async uploadAvatar(
    file: Express.Multer.File,
    userId: number
  ): Promise<string> {
    try {
      // 图片处理：压缩和调整尺寸
      const processedImage = await sharp(file.buffer)
        .resize(200, 200, {
          fit: 'cover',
          position: 'center'
        })
        .jpeg({ quality: 80 })
        .toBuffer();

      // 生成文件名
      const fileName = `avatar-${userId}-${uuidv4()}.jpg`;

      // 上传到MinIO
      await minioClient.putObject(
        BUCKETS.USER_AVATARS,
        fileName,
        processedImage,
        processedImage.length,
        {
          'Content-Type': 'image/jpeg',
          'Cache-Control': 'max-age=31536000' // 1年缓存
        }
      );

      // 返回访问URL
      const imageUrl = await this.getImageUrl(BUCKETS.USER_AVATARS, fileName);
      return imageUrl;
    } catch (error) {
      console.error('头像上传失败:', error);
      throw new Error('头像上传失败');
    }
  }

  // 上传食物图片
  static async uploadFoodImage(
    file: Express.Multer.File,
    foodId: number
  ): Promise<string> {
    try {
      // 图片处理：多尺寸生成
      const originalImage = await sharp(file.buffer)
        .resize(800, 600, {
          fit: 'inside',
          withoutEnlargement: true
        })
        .jpeg({ quality: 85 })
        .toBuffer();

      const thumbnailImage = await sharp(file.buffer)
        .resize(300, 225, {
          fit: 'cover',
          position: 'center'
        })
        .jpeg({ quality: 75 })
        .toBuffer();

      const fileName = `food-${foodId}-${uuidv4()}`;
      const originalFileName = `${fileName}-original.jpg`;
      const thumbnailFileName = `${fileName}-thumb.jpg`;

      // 上传原图
      await minioClient.putObject(
        BUCKETS.FOOD_IMAGES,
        originalFileName,
        originalImage,
        originalImage.length,
        {
          'Content-Type': 'image/jpeg',
          'Cache-Control': 'max-age=31536000'
        }
      );

      // 上传缩略图
      await minioClient.putObject(
        BUCKETS.FOOD_IMAGES,
        thumbnailFileName,
        thumbnailImage,
        thumbnailImage.length,
        {
          'Content-Type': 'image/jpeg',
          'Cache-Control': 'max-age=31536000'
        }
      );

      // 返回原图URL
      const imageUrl = await this.getImageUrl(BUCKETS.FOOD_IMAGES, originalFileName);
      return imageUrl;
    } catch (error) {
      console.error('食物图片上传失败:', error);
      throw new Error('食物图片上传失败');
    }
  }

  // 获取图片访问URL
  static async getImageUrl(bucketName: string, fileName: string): Promise<string> {
    try {
      // 生成预签名URL（24小时有效）
      const url = await minioClient.presignedUrl('GET', bucketName, fileName, 24 * 60 * 60);
      return url;
    } catch (error) {
      console.error('获取图片URL失败:', error);
      throw new Error('获取图片URL失败');
    }
  }

  // 删除图片
  static async deleteImage(bucketName: string, fileName: string): Promise<void> {
    try {
      await minioClient.removeObject(bucketName, fileName);
      console.log(`✅ 删除图片: ${bucketName}/${fileName}`);
    } catch (error) {
      console.error('删除图片失败:', error);
      throw new Error('删除图片失败');
    }
  }

  // 批量删除图片
  static async deleteImages(bucketName: string, fileNames: string[]): Promise<void> {
    try {
      await minioClient.removeObjects(bucketName, fileNames);
      console.log(`✅ 批量删除图片: ${fileNames.length}张`);
    } catch (error) {
      console.error('批量删除图片失败:', error);
      throw new Error('批量删除图片失败');
    }
  }
}

// 导出multer中间件
export const uploadSingle = upload.single('image');
export const uploadMultiple = upload.array('images', 5);
```

#### 1.2.4 图片上传控制器
```typescript
// src/controllers/uploadController.ts
import { Response } from 'express';
import { AuthRequest } from '../middleware/auth';
import { UploadService } from '../services/uploadService';
import { db } from '../config/database';

/**
 * @swagger
 * /api/upload/avatar:
 *   post:
 *     summary: 上传用户头像
 *     tags: [文件上传]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               image:
 *                 type: string
 *                 format: binary
 *                 description: 头像图片文件
 *     responses:
 *       200:
 *         description: 上传成功
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   type: object
 *                   properties:
 *                     imageUrl:
 *                       type: string
 */
export const uploadAvatar = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.file) {
      res.status(400).json({
        success: false,
        message: '请选择要上传的图片文件'
      });
      return;
    }

    const userId = req.user!.userId;

    // 获取用户当前头像URL（用于删除旧头像）
    const [rows] = await db.execute(
      'SELECT avatar FROM users WHERE id = ?',
      [userId]
    );
    const user = (rows as any[])[0];
    const oldAvatarUrl = user?.avatar;

    // 上传新头像
    const imageUrl = await UploadService.uploadAvatar(req.file, userId);

    // 更新数据库中的头像URL
    await db.execute(
      'UPDATE users SET avatar = ? WHERE id = ?',
      [imageUrl, userId]
    );

    // 删除旧头像（如果存在）
    if (oldAvatarUrl && oldAvatarUrl.includes('minio')) {
      try {
        const oldFileName = oldAvatarUrl.split('/').pop();
        if (oldFileName) {
          await UploadService.deleteImage('user-avatars', oldFileName);
        }
      } catch (error) {
        console.warn('删除旧头像失败:', error);
      }
    }

    res.json({
      success: true,
      message: '头像上传成功',
      data: {
        imageUrl
      }
    });
  } catch (error) {
    console.error('头像上传错误:', error);
    res.status(500).json({
      success: false,
      message: error instanceof Error ? error.message : '上传失败'
    });
  }
};

/**
 * @swagger
 * /api/upload/food-image:
 *   post:
 *     summary: 上传食物图片
 *     tags: [文件上传]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               image:
 *                 type: string
 *                 format: binary
 *               foodId:
 *                 type: integer
 *                 description: 食物ID
 *     responses:
 *       200:
 *         description: 上传成功
 */
export const uploadFoodImage = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.file) {
      res.status(400).json({
        success: false,
        message: '请选择要上传的图片文件'
      });
      return;
    }

    const { foodId } = req.body;
    if (!foodId) {
      res.status(400).json({
        success: false,
        message: '食物ID不能为空'
      });
      return;
    }

    // 验证食物是否存在
    const [rows] = await db.execute(
      'SELECT id, image_url FROM foods WHERE id = ?',
      [foodId]
    );
    if ((rows as any[]).length === 0) {
      res.status(404).json({
        success: false,
        message: '食物不存在'
      });
      return;
    }

    const food = (rows as any[])[0];
    const oldImageUrl = food.image_url;

    // 上传新图片
    const imageUrl = await UploadService.uploadFoodImage(req.file, foodId);

    // 更新数据库中的图片URL
    await db.execute(
      'UPDATE foods SET image_url = ? WHERE id = ?',
      [imageUrl, foodId]
    );

    // 删除旧图片
    if (oldImageUrl && oldImageUrl.includes('minio')) {
      try {
        const oldFileName = oldImageUrl.split('/').pop();
        if (oldFileName) {
          await UploadService.deleteImage('food-images', oldFileName);
        }
      } catch (error) {
        console.warn('删除旧食物图片失败:', error);
      }
    }

    res.json({
      success: true,
      message: '食物图片上传成功',
      data: {
        imageUrl
      }
    });
  } catch (error) {
    console.error('食物图片上传错误:', error);
    res.status(500).json({
      success: false,
      message: error instanceof Error ? error.message : '上传失败'
    });
  }
};
```

#### 1.2.5 图片上传路由
```typescript
// src/routes/uploadRoutes.ts
import { Router } from 'express';
import { uploadAvatar, uploadFoodImage } from '../controllers/uploadController';
import { authenticateToken } from '../middleware/auth';
import { uploadSingle } from '../services/uploadService';

const router = Router();

// 上传头像
router.post('/avatar', authenticateToken, uploadSingle, uploadAvatar);

// 上传食物图片
router.post('/food-image', authenticateToken, uploadSingle, uploadFoodImage);

export default router;
```

### 1.3 前端图片上传实现

#### 1.3.1 Vue3 + Vant图片上传组件
```vue
<!-- src/components/ImageUploader.vue -->
<template>
  <div class="image-uploader">
    <van-uploader
      v-model="fileList"
      :max-count="maxCount"
      :max-size="maxSize"
      :upload="uploadFile"
      :before-upload="beforeUpload"
      :accept="accept"
      :preview-size="previewSize"
      @oversize="onOversize"
      @delete="onDelete"
    >
      <template #default>
        <div class="upload-area">
          <van-icon name="plus" size="24" />
          <div class="upload-text">{{ placeholder }}</div>
        </div>
      </template>
    </van-uploader>
  </div>
</template>

<script setup lang="ts">
import { ref, watch, defineProps, defineEmits } from 'vue';
import { showToast } from 'vant';
import { uploadAPI } from '@/api/upload';

interface Props {
  modelValue?: string[];
  maxCount?: number;
  maxSize?: number;
  accept?: string;
  uploadType?: 'avatar' | 'food';
  placeholder?: string;
  previewSize?: number | string;
  foodId?: number;
}

interface Emits {
  (e: 'update:modelValue', value: string[]): void;
  (e: 'upload-success', url: string): void;
  (e: 'upload-error', error: string): void;
}

const props = withDefaults(defineProps<Props>(), {
  maxCount: 1,
  maxSize: 5 * 1024 * 1024, // 5MB
  accept: 'image/*',
  uploadType: 'avatar',
  placeholder: '上传图片',
  previewSize: 80
});

const emit = defineEmits<Emits>();

const fileList = ref<any[]>([]);

// 监听外部值变化
watch(() => props.modelValue, (newValue) => {
  if (newValue && newValue.length > 0) {
    fileList.value = newValue.map((url, index) => ({
      url,
      isImage: true,
      file: null,
      status: 'done',
      uid: `${index}`
    }));
  } else {
    fileList.value = [];
  }
}, { immediate: true });

// 上传前验证
const beforeUpload = (file: File) => {
  const isImage = file.type.startsWith('image/');
  if (!isImage) {
    showToast('请上传图片格式的文件');
    return false;
  }

  const isLt5M = file.size < props.maxSize;
  if (!isLt5M) {
    showToast(`图片大小不能超过 ${props.maxSize / 1024 / 1024}MB`);
    return false;
  }

  return true;
};

// 文件上传
const uploadFile = async (file: File) => {
  try {
    const formData = new FormData();
    formData.append('image', file);

    if (props.uploadType === 'food' && props.foodId) {
      formData.append('foodId', props.foodId.toString());
    }

    let response;
    if (props.uploadType === 'avatar') {
      response = await uploadAPI.uploadAvatar(formData);
    } else {
      response = await uploadAPI.uploadFoodImage(formData);
    }

    const imageUrl = response.data.imageUrl;

    // 更新外部值
    const newUrls = [...(props.modelValue || []), imageUrl];
    emit('update:modelValue', newUrls);
    emit('upload-success', imageUrl);

    showToast('上传成功');

    return {
      url: imageUrl,
      isImage: true
    };
  } catch (error: any) {
    const errorMessage = error.response?.data?.message || '上传失败';
    showToast(errorMessage);
    emit('upload-error', errorMessage);
    throw error;
  }
};

// 文件超出大小限制
const onOversize = () => {
  showToast(`文件大小不能超过 ${props.maxSize / 1024 / 1024}MB`);
};

// 删除文件
const onDelete = (file: any, detail: any) => {
  const urls = props.modelValue || [];
  const newUrls = urls.filter((_, index) => index !== detail.index);
  emit('update:modelValue', newUrls);
};
</script>

<style scoped>
.image-uploader {
  width: 100%;
}

.upload-area {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  width: 80px;
  height: 80px;
  background-color: #fafafa;
  border: 1px dashed #c8c9cc;
  border-radius: 6px;
  color: #c8c9cc;
}

.upload-text {
  margin-top: 4px;
  font-size: 12px;
}
</style>
```

#### 1.3.2 头像上传使用示例
```vue
<!-- src/views/Profile.vue -->
<template>
  <div class="profile-page">
    <van-nav-bar title="个人信息" left-arrow @click-left="$router.go(-1)" />

    <div class="avatar-section">
      <h3>头像设置</h3>
      <ImageUploader
        v-model="avatarUrls"
        upload-type="avatar"
        placeholder="上传头像"
        :max-count="1"
        @upload-success="onAvatarUploadSuccess"
      />
    </div>

    <van-form @submit="onSubmit">
      <van-cell-group>
        <van-field
          v-model="form.nickname"
          name="nickname"
          label="昵称"
          placeholder="请输入昵称"
        />
        <van-field
          v-model="form.email"
          name="email"
          label="邮箱"
          placeholder="请输入邮箱"
        />
      </van-cell-group>

      <div style="margin: 16px;">
        <van-button
          round
          block
          type="primary"
          native-type="submit"
          :loading="loading"
        >
          保存
        </van-button>
      </div>
    </van-form>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue';
import { showToast } from 'vant';
import ImageUploader from '@/components/ImageUploader.vue';
import { useAuthStore } from '@/stores/auth';

const authStore = useAuthStore();
const loading = ref(false);
const avatarUrls = ref<string[]>([]);
const form = ref({
  nickname: '',
  email: ''
});

onMounted(async () => {
  // 加载用户信息
  const userInfo = await authStore.fetchUser();
  form.value = {
    nickname: userInfo.nickname || '',
    email: userInfo.email || ''
  };

  if (userInfo.avatar) {
    avatarUrls.value = [userInfo.avatar];
  }
});

const onAvatarUploadSuccess = (url: string) => {
  console.log('头像上传成功:', url);
  // 可以在这里更新用户store中的头像信息
  authStore.updateAvatar(url);
};

const onSubmit = async () => {
  loading.value = true;
  try {
    await authStore.updateProfile(form.value);
    showToast('保存成功');
  } catch (error) {
    showToast('保存失败');
  } finally {
    loading.value = false;
  }
};
</script>
```

### 1.4 图片读取和访问优化

#### 1.4.1 CDN集成
```typescript
// src/utils/imageUtils.ts
const CDN_BASE_URL = process.env.VUE_APP_CDN_BASE_URL || '';
const MINIO_BASE_URL = process.env.VUE_APP_MINIO_BASE_URL || 'http://localhost:9000';

export class ImageUtils {
  // 获取优化后的图片URL
  static getOptimizedImageUrl(
    originalUrl: string,
    options: {
      width?: number;
      height?: number;
      quality?: number;
      format?: 'webp' | 'jpeg' | 'png';
    } = {}
  ): string {
    if (!originalUrl) return '';

    // 如果是MinIO URL且有CDN配置，使用CDN
    if (originalUrl.includes('minio') && CDN_BASE_URL) {
      const path = originalUrl.replace(MINIO_BASE_URL, '');
      return `${CDN_BASE_URL}${path}`;
    }

    // 如果支持图片处理参数
    if (options.width || options.height || options.quality || options.format) {
      const params = new URLSearchParams();
      if (options.width) params.set('w', options.width.toString());
      if (options.height) params.set('h', options.height.toString());
      if (options.quality) params.set('q', options.quality.toString());
      if (options.format) params.set('f', options.format);

      const separator = originalUrl.includes('?') ? '&' : '?';
      return `${originalUrl}${separator}${params.toString()}`;
    }

    return originalUrl;
  }

  // 获取缩略图URL
  static getThumbnailUrl(originalUrl: string): string {
    return this.getOptimizedImageUrl(originalUrl, {
      width: 300,
      height: 300,
      quality: 75,
      format: 'webp'
    });
  }

  // 预加载图片
  static preloadImage(url: string): Promise<void> {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve();
      img.onerror = reject;
      img.src = url;
    });
  }
}
```

## 2. 阿里云域名购买与1Panel部署全流程

### 2.1 阿里云域名购买流程

#### 2.1.1 域名注册步骤
```bash
# 1. 登录阿里云控制台
https://ecs.console.aliyun.com/

# 2. 进入域名服务
产品与服务 → 域名与网站 → 域名

# 3. 域名查询与注册
- 输入想要注册的域名
- 选择合适的后缀（.com, .cn, .net等）
- 检查域名可用性
- 选择注册年限（建议3-5年）
- 添加到购物车并支付

# 4. 域名信息完善
- 填写域名所有者信息
- 上传身份证明文件
- 等待审核通过（通常1-3个工作日）
```

#### 2.1.2 域名解析配置
```bash
# 域名解析设置步骤：

# 1. 进入云解析DNS
控制台 → 产品与服务 → 域名与网站 → 云解析DNS

# 2. 添加解析记录
记录类型: A
主机记录: @（根域名）或 www（子域名）
解析线路: 默认
记录值: 服务器公网IP地址
TTL: 600秒

# 3. 常用解析记录配置
@       A    your_server_ip     # 根域名指向
www     A    your_server_ip     # www子域名指向
api     A    your_server_ip     # API子域名指向
admin   A    your_server_ip     # 管理后台子域名指向

# 4. 验证解析生效
nslookup your-domain.com
ping your-domain.com
```

### 2.2 服务器环境准备

#### 2.2.1 阿里云ECS实例配置
```bash
# 推荐配置：
CPU: 2核心
内存: 4GB
存储: 40GB SSD云盘
带宽: 5Mbps
操作系统: CentOS 7.9 或 Ubuntu 20.04 LTS

# 安全组配置
入方向规则:
- HTTP: 80/80, 0.0.0.0/0
- HTTPS: 443/443, 0.0.0.0/0
- SSH: 22/22, 0.0.0.0/0
- 1Panel: 8888/8888, your_ip/32
- 自定义: 3000/3000, 0.0.0.0/0 (后端API)
- 自定义: 9000-9001/9000-9001, 0.0.0.0/0 (MinIO)
```

#### 2.2.2 基础环境安装
```bash
# 连接服务器
ssh root@your_server_ip

# 更新系统
yum update -y  # CentOS
# apt update && apt upgrade -y  # Ubuntu

# 安装基础工具
yum install -y wget curl vim git unzip  # CentOS
# apt install -y wget curl vim git unzip  # Ubuntu

# 安装Docker
curl -fsSL https://get.docker.com | bash
systemctl start docker
systemctl enable docker

# 安装Docker Compose
curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose

# 验证安装
docker --version
docker-compose --version
```

### 2.3 1Panel安装与配置

#### 2.3.1 1Panel安装
```bash
# 下载1Panel安装脚本
curl -sSL https://resource.fit2cloud.com/1panel/package/quick_start.sh -o quick_start.sh

# 执行安装
sudo bash quick_start.sh

# 查看面板信息
1pctl user-info

# 1Panel安装完成后显示信息:
# ==========================================
# 1Panel 安装完成
# ==========================================
# 面板地址: http://your_ip:8888/security_entrance
# 用户名: admin_username
# 密码: admin_password
# 入口: security_entrance_path
# ==========================================
```

#### 2.3.2 1Panel基础配置
```bash
# 1. 登录1Panel管理面板
浏览器访问: http://your_server_ip:8888/security_entrance

# 2. 初始化设置
- 修改默认密码
- 设置安全入口
- 配置SSL证书
- 开启防火墙

# 3. 安装必要应用
应用商店 → 搜索并安装:
- OpenResty (Web服务器)
- MySQL (数据库)
- Redis (缓存)
- MinIO (对象存储)
- phpMyAdmin (数据库管理，可选)
```

### 2.4 项目部署配置

#### 2.4.1 创建项目目录结构
```bash
# 在1Panel中创建网站
网站 → 创建网站 → 静态网站
域名: your-domain.com
项目目录: /opt/1panel/apps/openresty/openresty/www/sites/your-domain

# 创建完整目录结构
mkdir -p /opt/health-system/{frontend,backend,database,storage}
cd /opt/health-system

# 目录结构：
health-system/
├── frontend/          # 前端静态文件
├── backend/           # 后端API代码
├── database/          # 数据库文件
├── storage/           # 文件存储
└── docker-compose.yml # Docker编排文件
```

#### 2.4.2 Docker Compose配置
```yaml
# docker-compose.yml
version: '3.8'

services:
  # MySQL数据库
  mysql:
    image: mysql:8.0
    container_name: health-mysql
    restart: unless-stopped
    environment:
      MYSQL_ROOT_PASSWORD: your_mysql_root_password
      MYSQL_DATABASE: health_management
      MYSQL_USER: health_app
      MYSQL_PASSWORD: your_mysql_password
    volumes:
      - ./database/data:/var/lib/mysql
      - ./database/init:/docker-entrypoint-initdb.d
    ports:
      - "3306:3306"
    networks:
      - health-network

  # Redis缓存
  redis:
    image: redis:7-alpine
    container_name: health-redis
    restart: unless-stopped
    command: redis-server --requirepass your_redis_password
    volumes:
      - ./database/redis:/data
    ports:
      - "6379:6379"
    networks:
      - health-network

  # MinIO对象存储
  minio:
    image: quay.io/minio/minio:latest
    container_name: health-minio
    restart: unless-stopped
    environment:
      MINIO_ROOT_USER: minioadmin
      MINIO_ROOT_PASSWORD: your_minio_password
    volumes:
      - ./storage/minio/data:/data
      - ./storage/minio/config:/root/.minio
    ports:
      - "9000:9000"
      - "9001:9001"
    command: server /data --console-address ":9001"
    networks:
      - health-network

  # 后端API服务
  backend:
    build: ./backend
    container_name: health-backend
    restart: unless-stopped
    environment:
      NODE_ENV: production
      DB_HOST: mysql
      DB_USER: health_app
      DB_PASSWORD: your_mysql_password
      DB_NAME: health_management
      REDIS_HOST: redis
      REDIS_PASSWORD: your_redis_password
      MINIO_ENDPOINT: minio
      MINIO_ACCESS_KEY: minioadmin
      MINIO_SECRET_KEY: your_minio_password
      JWT_SECRET: your_jwt_secret
    volumes:
      - ./backend/logs:/app/logs
    ports:
      - "3000:3000"
    depends_on:
      - mysql
      - redis
      - minio
    networks:
      - health-network

networks:
  health-network:
    driver: bridge
```

#### 2.4.3 Nginx反向代理配置
```nginx
# /opt/1panel/apps/openresty/openresty/conf/conf.d/your-domain.conf

# 前端静态文件服务
server {
    listen 80;
    server_name your-domain.com www.your-domain.com;

    # 重定向到HTTPS
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name your-domain.com www.your-domain.com;

    # SSL证书配置
    ssl_certificate /opt/1panel/apps/openresty/openresty/ssl/your-domain.com/fullchain.pem;
    ssl_certificate_key /opt/1panel/apps/openresty/openresty/ssl/your-domain.com/privkey.pem;

    # SSL安全配置
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL:10m;

    # 前端静态文件
    location / {
        root /opt/health-system/frontend/dist;
        index index.html;
        try_files $uri $uri/ /index.html;

        # 缓存静态资源
        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
            expires 1y;
            add_header Cache-Control "public, immutable";
        }
    }

    # API代理
    location /api/ {
        proxy_pass http://127.0.0.1:3000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # 文件上传大小限制
        client_max_body_size 10M;
    }

    # MinIO对象存储代理
    location /storage/ {
        proxy_pass http://127.0.0.1:9000/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # CORS配置
        add_header Access-Control-Allow-Origin *;
        add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS";
        add_header Access-Control-Allow-Headers "Content-Type, Authorization";
    }
}

# 管理后台
server {
    listen 443 ssl http2;
    server_name admin.your-domain.com;

    # SSL证书配置（可以使用通配符证书）
    ssl_certificate /opt/1panel/apps/openresty/openresty/ssl/your-domain.com/fullchain.pem;
    ssl_certificate_key /opt/1panel/apps/openresty/openresty/ssl/your-domain.com/privkey.pem;

    # 管理后台静态文件
    location / {
        root /opt/health-system/frontend-admin/dist;
        index index.html;
        try_files $uri $uri/ /index.html;
    }

    # API代理（与主站共用）
    location /api/ {
        proxy_pass http://127.0.0.1:3000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

### 2.5 自动化部署脚本

#### 2.5.1 部署脚本
```bash
#!/bin/bash
# deploy.sh - 健康管理系统自动化部署脚本

set -e

PROJECT_DIR="/opt/health-system"
DOMAIN="your-domain.com"
GIT_REPO="https://github.com/your-username/health-system.git"

echo "🚀 开始部署健康管理系统..."

# 1. 检查环境
echo "📋 检查部署环境..."
command -v docker >/dev/null 2>&1 || { echo "❌ Docker未安装"; exit 1; }
command -v docker-compose >/dev/null 2>&1 || { echo "❌ Docker Compose未安装"; exit 1; }

# 2. 创建项目目录
echo "📁 创建项目目录..."
mkdir -p $PROJECT_DIR
cd $PROJECT_DIR

# 3. 克隆代码
echo "📥 克隆项目代码..."
if [ -d ".git" ]; then
    git pull origin main
else
    git clone $GIT_REPO .
fi

# 4. 构建前端
echo "🔨 构建前端项目..."
cd frontend
npm install
npm run build
cd ..

cd frontend-admin
npm install
npm run build
cd ..

# 5. 构建后端
echo "🔨 构建后端项目..."
cd backend
npm install
npm run build
cd ..

# 6. 配置环境变量
echo "⚙️  配置环境变量..."
cat > .env << EOF
# 数据库配置
MYSQL_ROOT_PASSWORD=$(openssl rand -base64 32)
MYSQL_PASSWORD=$(openssl rand -base64 32)

# Redis配置
REDIS_PASSWORD=$(openssl rand -base64 32)

# MinIO配置
MINIO_PASSWORD=$(openssl rand -base64 32)

# JWT密钥
JWT_SECRET=$(openssl rand -base64 64)

# 域名配置
DOMAIN=$DOMAIN
EOF

# 7. 启动服务
echo "🐳 启动Docker服务..."
docker-compose up -d

# 8. 等待服务启动
echo "⏳ 等待服务启动..."
sleep 30

# 9. 初始化数据库
echo "🗄️  初始化数据库..."
docker-compose exec backend npm run db:migrate
docker-compose exec backend npm run db:seed

# 10. 配置SSL证书
echo "🔒 配置SSL证书..."
docker run --rm -it \
  -v /opt/1panel/apps/openresty/openresty/ssl:/etc/letsencrypt \
  certbot/certbot certonly \
  --standalone \
  --email your-email@example.com \
  --agree-tos \
  --no-eff-email \
  -d $DOMAIN \
  -d www.$DOMAIN \
  -d admin.$DOMAIN

# 11. 重载Nginx配置
echo "🔄 重载Nginx配置..."
docker exec openresty nginx -s reload

# 12. 显示部署结果
echo "✅ 部署完成！"
echo "===================="
echo "前端地址: https://$DOMAIN"
echo "管理后台: https://admin.$DOMAIN"
echo "API文档: https://$DOMAIN/api-docs"
echo "MinIO控制台: https://$DOMAIN:9001"
echo "===================="

# 13. 显示重要信息
echo "🔑 重要信息（请妥善保存）："
echo "MySQL root密码: $(grep MYSQL_ROOT_PASSWORD .env | cut -d'=' -f2)"
echo "MinIO密码: $(grep MINIO_PASSWORD .env | cut -d'=' -f2)"
echo "Redis密码: $(grep REDIS_PASSWORD .env | cut -d'=' -f2)"
```

#### 2.5.2 更新部署脚本
```bash
#!/bin/bash
# update.sh - 系统更新脚本

PROJECT_DIR="/opt/health-system"
cd $PROJECT_DIR

echo "🔄 开始更新系统..."

# 1. 备份数据库
echo "💾 备份数据库..."
docker-compose exec mysql mysqldump -u root -p$MYSQL_ROOT_PASSWORD health_management > backup/db_$(date +%Y%m%d_%H%M%S).sql

# 2. 拉取最新代码
echo "📥 拉取最新代码..."
git pull origin main

# 3. 重新构建前端
echo "🔨 重新构建前端..."
cd frontend && npm install && npm run build && cd ..
cd frontend-admin && npm install && npm run build && cd ..

# 4. 重新构建后端
echo "🔨 重新构建后端..."
cd backend && npm install && npm run build && cd ..

# 5. 重启服务
echo "🔄 重启服务..."
docker-compose down
docker-compose up -d

echo "✅ 更新完成！"
```

这份技术难点实现指南详细介绍了图片上传到MinIO的完整技术链路以及通过1Panel部署项目的完整流程，包含了所有必要的配置文件和脚本，可以直接用于生产环境部署。