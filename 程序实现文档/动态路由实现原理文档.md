# Vue-Pure-Admin 动态路由实现原理及菜单管理关系

## 1. 概述

Vue-Pure-Admin 的动态路由系统允许从后端动态加载路由配置，并根据用户权限动态渲染菜单。该系统的核心在于**路由配置与菜单管理的解耦**，通过后端API返回路由配置，前端动态注册路由并生成菜单。

---

## 2. 核心概念

### 2.1 路由类型

#### 静态路由（Static Routes）
- 定义位置：`src/router/modules/*.ts`
- 特点：
  - 编译时确定
  - 无需后端动态配置
  - 适用于公共页面（登录、404等）
- 示例：
```typescript
// src/router/modules/home.ts
export default {
  path: "/",
  name: "Home",
  component: Layout,
  redirect: "/dashboard",
  meta: {
    icon: "ep/home-filled",
    title: "首页",
    rank: 0
  },
  children: [
    {
      path: "/dashboard",
      name: "Dashboard",
      component: () => import("@/views/dashboard/index.vue"),
      meta: {
        title: "数据趋势"
      }
    }
  ]
};
```

#### 动态路由（Async Routes）
- 数据来源：后端API `/get-async-routes`
- 特点：
  - 运行时动态加载
  - 根据用户角色/权限返回
  - 灵活可配置
- 数据格式（后端返回）：
```typescript
{
  path: "/system",
  meta: {
    icon: "ri:settings-3-line",
    title: "menus.pureSysManagement",
    rank: 10
  },
  children: [
    {
      path: "/system/menu/index",
      name: "SystemMenu",
      component: "system/menu/index", // 组件路径字符串
      meta: {
        icon: "ep:menu",
        title: "menus.pureSystemMenu",
        roles: ["admin"]  // 角色权限控制
      }
    }
  ]
}
```

---

## 3. 完整调用链路

### 3.1 应用启动流程

```
1. 应用启动
   └→ router 初始化（router/index.ts）
      └→ 加载静态路由（import.meta.glob）
         └→ 处理成二级路由（formatTwoStageRoutes）
```

### 3.2 用户登录后的路由加载流程

```
用户登录成功
   └→ 存储用户信息到 localStorage (含 roles)
      └→ 路由守卫 router.beforeEach 触发
         └→ 检测 wholeMenus 是否为空
            └→ 调用 initRouter()  <-- 关键入口
               ├→ 检查缓存配置（CachingAsyncRoutes）
               │  ├→ 有缓存：从 localStorage 读取
               │  └→ 无缓存：调用 API getAsyncRoutes()
               │
               ├→ 后端返回路由数据
               │  └→ handleAsyncRoutes(routeList)
               │     ├→ addAsyncRoutes() - 路由规范化
               │     │  ├→ 标记 meta.backstage = true
               │     │  ├→ 设置 redirect（默认第一个子路由）
               │     │  ├→ 设置 name（父级 + "Parent"）
               │     │  └→ 组件路径字符串 → 组件对象
               │     │     └→ modulesRoutes["/src/views/system/menu/index.vue"]
               │     │
               │     ├→ formatFlatteningRoutes() - 扁平化
               │     │  └→ 将多级路由处理成一维数组
               │     │
               │     ├→ 动态注册路由
               │     │  └→ router.addRoute(v)
               │     │
               │     └→ 更新菜单
               │        └→ usePermissionStoreHook().handleWholeMenus(routeList)
               │
               └→ addPathMatch() - 添加404路由
```

### 3.3 详细代码流程

#### 步骤1：路由守卫检测（router/index.ts:172-189）

```typescript
router.beforeEach((to, _from, next) => {
  if (usePermissionStoreHook().wholeMenus.length === 0 && to.path !== "/login") {
    // 菜单为空，说明需要初始化路由
    initRouter().then((router: Router) => {
      // 路由初始化完成后，处理标签页、菜单等
      if (isAllEmpty(to.name)) {
        router.push(to.fullPath); // 确保路由跳转生效
      }
    });
  }
});
```

#### 步骤2：初始化路由（router/utils.ts:200-227）

```typescript
function initRouter() {
  if (getConfig()?.CachingAsyncRoutes) {
    // 开启动态路由缓存
    const asyncRouteList = storageLocal().getItem("async-routes");
    if (asyncRouteList && asyncRouteList?.length > 0) {
      return new Promise(resolve => {
        handleAsyncRoutes(asyncRouteList);
        resolve(router);
      });
    }
  }

  // 从后端获取动态路由
  return new Promise(resolve => {
    getAsyncRoutes().then(({ data }) => {
      handleAsyncRoutes(cloneDeep(data));
      storageLocal().setItem("async-routes", data); // 缓存
      resolve(router);
    });
  });
}
```

#### 步骤3：处理异步路由（router/utils.ts:158-197）

```typescript
function handleAsyncRoutes(routeList) {
  if (routeList.length === 0) {
    usePermissionStoreHook().handleWholeMenus(routeList);
  } else {
    // 扁平化 + 规范化
    formatFlatteningRoutes(addAsyncRoutes(routeList)).map((v: RouteRecordRaw) => {
      // 防止重复添加路由
      if (router.options.routes[0].children.findIndex(
        value => value.path === v.path
      ) !== -1) {
        return;
      }

      // 1. 添加到 router.options.routes（用于菜单渲染）
      router.options.routes[0].children.push(v);

      // 2. 路由排序
      ascending(router.options.routes[0].children);

      // 3. 动态注册到路由实例（router.addRoute）
      if (!router.hasRoute(v?.name)) {
        router.addRoute(v);
      }
    });

    // 4. 更新权限store的菜单数据
    usePermissionStoreHook().handleWholeMenus(routeList);
  }

  // 5. 添加404页面
  addPathMatch();
}
```

#### 步骤4：路由规范化（router/utils.ts:309-335）

```typescript
function addAsyncRoutes(arrRoutes: Array<RouteRecordRaw>) {
  const modulesRoutesKeys = Object.keys(modulesRoutes);

  arrRoutes.forEach((v: RouteRecordRaw) => {
    // 1. 标记为后端路由
    v.meta.backstage = true;

    // 2. 设置 redirect（默认第一个子路由）
    if (v?.children && v.children.length && !v.redirect) {
      v.redirect = v.children[0].path;
    }

    // 3. 设置 name（避免父子重名）
    if (v?.children && v.children.length && !v.name) {
      v.name = (v.children[0].name as string) + "Parent";
    }

    // 4. 处理组件路径
    if (v.meta?.frameSrc) {
      // iframe 页面
      v.component = IFrame;
    } else {
      // 字符串路径 → 组件对象
      // 示例："system/menu/index" → modulesRoutes["/src/views/system/menu/index.vue"]
      const index = v?.component
        ? modulesRoutesKeys.findIndex(ev => ev.includes(v.component as any))
        : modulesRoutesKeys.findIndex(ev => ev.includes(v.path));
      v.component = modulesRoutes[modulesRoutesKeys[index]];
    }

    // 5. 递归处理子路由
    if (v?.children && v.children.length) {
      addAsyncRoutes(v.children);
    }
  });

  return arrRoutes;
}
```

---

## 4. 菜单管理与动态路由的关系

### 4.1 当前项目现状（已移除动态路由）

**文件位置：** `src/router/utils.ts:194-202`

```typescript
/** 初始化路由（简化版本，不使用动态路由）*/
function initRouter() {
  return new Promise(resolve => {
    // 初始化菜单（使用静态路由）
    usePermissionStoreHook().handleWholeMenus([]);
    addPathMatch();
    resolve(router);
  });
}
```

**特点：**
- ✅ 简单、可预测
- ✅ 性能好（无需API请求）
- ✅ 开发效率高
- ❌ 无法动态控制权限
- ❌ 菜单管理模块仅用于记录，不影响实际路由

### 4.2 Vue-Pure-Admin 原始实现（动态路由）

#### 后端API接口

**接口地址：** `GET /api/admin/menus`

**返回格式：**
```typescript
{
  "data": [
    {
      "path": "/system",
      "meta": {
        "icon": "ri:settings-3-line",
        "title": "系统管理",
        "rank": 10
      },
      "children": [
        {
          "path": "/system/menu/index",
          "name": "SystemMenu",
          "component": "system/menu/index",  // 组件路径
          "meta": {
            "icon": "ep:menu",
            "title": "菜单管理",
            "roles": ["admin"]  // 权限控制
          }
        }
      ]
    }
  ]
}
```

#### 菜单管理的作用

1. **管理员在菜单管理页面操作：**
   - 新增菜单：`POST /api/admin/menus`
   - 修改菜单：`PUT /api/admin/menus/:id`
   - 删除菜单：`DELETE /api/admin/menus/:id`

2. **后端存储到数据库：**
```sql
CREATE TABLE menus (
  id INT PRIMARY KEY,
  parent_id INT,
  title VARCHAR(100),
  type ENUM('menu', 'button'),
  path VARCHAR(200),
  component VARCHAR(200),
  icon VARCHAR(50),
  permission VARCHAR(100),
  sort INT,
  status TINYINT
);
```

3. **用户登录时：**
   - 后端根据用户角色查询菜单
   - 返回该用户有权限的菜单列表
   - 前端动态注册路由

4. **实时生效：**
   - 管理员修改菜单后
   - 用户刷新页面
   - 重新调用 `GET /get-async-routes`
   - 新菜单立即生效

### 4.3 对比总结

| 特性 | 静态路由（当前） | 动态路由（vue-pure-admin） |
|------|------------------|----------------------------|
| **路由定义** | `src/router/modules/*.ts` | 后端API返回 |
| **菜单生成** | 读取静态路由配置 | 后端动态生成 |
| **权限控制** | 前端硬编码 | 后端数据库配置 |
| **修改菜单** | 修改代码重新部署 | 后台管理界面即时修改 |
| **性能** | 最优（无API请求） | 稍差（需请求API） |
| **灵活性** | 低 | 高 |
| **菜单管理模块** | 仅记录，不生效 | 直接控制路由和菜单 |

---

## 5. 如何实现动态路由（恢复完整功能）

### 5.1 后端实现

#### 1. 数据库设计

```sql
CREATE TABLE `menus` (
  `id` int NOT NULL AUTO_INCREMENT,
  `parent_id` int DEFAULT 0,
  `title` varchar(100) NOT NULL,
  `type` enum('menu','button') DEFAULT 'menu',
  `path` varchar(200) DEFAULT NULL,
  `component` varchar(200) DEFAULT NULL,
  `icon` varchar(50) DEFAULT NULL,
  `permission` varchar(100) DEFAULT NULL,
  `sort` int DEFAULT 0,
  `status` tinyint DEFAULT 1,
  `created_at` timestamp DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
);

CREATE TABLE `role_menus` (
  `role_id` int NOT NULL,
  `menu_id` int NOT NULL,
  PRIMARY KEY (`role_id`, `menu_id`)
);
```

#### 2. API实现（Node.js/Express示例）

```javascript
// GET /api/get-async-routes
router.get('/get-async-routes', async (req, res) => {
  const { userId } = req.user; // 从JWT获取

  // 1. 查询用户角色
  const userRoles = await db.query(`
    SELECT role_id FROM user_roles WHERE user_id = ?
  `, [userId]);

  const roleIds = userRoles.map(r => r.role_id);

  // 2. 查询角色对应的菜单
  const menus = await db.query(`
    SELECT DISTINCT m.*
    FROM menus m
    INNER JOIN role_menus rm ON m.id = rm.menu_id
    WHERE rm.role_id IN (?) AND m.status = 1 AND m.type = 'menu'
    ORDER BY m.sort ASC
  `, [roleIds]);

  // 3. 构建树形结构
  const menuTree = buildTree(menus, 0);

  res.json({
    success: true,
    data: menuTree
  });
});

function buildTree(menus, parentId) {
  return menus
    .filter(m => m.parent_id === parentId)
    .map(menu => ({
      path: menu.path,
      name: menu.name || toCamelCase(menu.path),
      component: menu.component,
      meta: {
        icon: menu.icon,
        title: menu.title,
        rank: menu.sort
      },
      children: buildTree(menus, menu.id)
    }));
}
```

### 5.2 前端实现

#### 1. 恢复动态路由逻辑

**文件：** `src/router/utils.ts`

```typescript
// 取消注释
import { getAsyncRoutes } from "@/api/routes";

function initRouter() {
  if (getConfig()?.CachingAsyncRoutes) {
    const asyncRouteList = storageLocal().getItem("async-routes");
    if (asyncRouteList && asyncRouteList?.length > 0) {
      return new Promise(resolve => {
        handleAsyncRoutes(asyncRouteList);
        resolve(router);
      });
    }
  }

  return new Promise(resolve => {
    getAsyncRoutes().then(({ data }) => {
      handleAsyncRoutes(cloneDeep(data));
      storageLocal().setItem("async-routes", data);
      resolve(router);
    });
  });
}
```

#### 2. API接口定义

**文件：** `src/api/routes.ts`

```typescript
import { http } from "@/utils/http";

type Result = {
  success: boolean;
  data: Array<any>;
};

export const getAsyncRoutes = () => {
  return http.request<Result>("get", "/api/get-async-routes");
};
```

#### 3. 菜单管理CRUD

**当前已实现：**
- ✅ 类型定义（`types.ts`）
- ✅ 表单验证（`rule.ts`）
- ✅ 业务逻辑（`hooks.tsx`）
- ✅ API接口（`admin.ts`）
- ✅ 视图组件（`index.vue`、`form.vue`）

**缺少的部分：**
- ❌ 后端API实现（`POST/PUT/DELETE /api/admin/menus`）
- ❌ 后端路由生成逻辑（`GET /api/get-async-routes`）
- ❌ 权限控制中间件

---

## 6. 工作流程示例

### 场景：管理员添加新菜单

1. **管理员操作：**
   - 访问菜单管理页面
   - 点击"新增菜单"
   - 填写表单：
     - 菜单名称：用户管理
     - 路径：/system/user/index
     - 组件：system/user/index
     - 图标：ri:user-line
     - 权限：admin
   - 点击保存

2. **前端请求：**
```typescript
await postAdminMenus({
  parent_id: 1,
  title: "用户管理",
  type: "menu",
  path: "/system/user/index",
  component: "system/user/index",
  icon: "ri:user-line",
  permission: "admin",
  sort: 1,
  status: 1
});
```

3. **后端处理：**
```sql
INSERT INTO menus (parent_id, title, type, path, component, icon, sort, status)
VALUES (1, '用户管理', 'menu', '/system/user/index', 'system/user/index', 'ri:user-line', 1, 1);

-- 假设新菜单ID为10，将其分配给admin角色
INSERT INTO role_menus (role_id, menu_id) VALUES (1, 10);
```

4. **用户刷新页面：**
   - 路由守卫触发
   - 调用 `initRouter()`
   - 请求 `/api/get-async-routes`
   - 后端返回包含新菜单的路由数据
   - 前端动态注册路由
   - 侧边栏显示新菜单

---

## 7. 关键技术点

### 7.1 组件路径解析

**后端返回字符串：**
```typescript
{
  component: "system/menu/index"
}
```

**前端转换为组件对象：**
```typescript
const modulesRoutes = import.meta.glob("/src/views/**/*.{vue,tsx}");
// modulesRoutes = {
//   "/src/views/system/menu/index.vue": () => import("...")
// }

const index = modulesRoutesKeys.findIndex(ev =>
  ev.includes("system/menu/index")
);
v.component = modulesRoutes[modulesRoutesKeys[index]];
```

### 7.2 路由扁平化

**原因：** Vue Router 的 keep-alive 只支持二级缓存

**处理流程：**
```
三级路由：
/system
  └─ /system/user
       └─ /system/user/detail

扁平化后：
/system (父级)
  ├─ /system/user
  └─ /system/user/detail
```

### 7.3 权限过滤

```typescript
// 方式1：路由级别（meta.roles）
{
  meta: {
    roles: ["admin"]  // 只有admin角色可见
  }
}

// 方式2：按钮级别（meta.auths）
{
  meta: {
    auths: ["user:add", "user:edit", "user:delete"]
  }
}

// 使用
v-if="hasAuth('user:add')"
```

---

## 8. 常见问题

### Q1：菜单管理修改后不生效？
**A：** 需要清除缓存
```typescript
storageLocal().removeItem("async-routes");
window.location.reload();
```

### Q2：动态路由404？
**A：** 检查组件路径是否匹配
```typescript
// 后端返回：component: "system/menu/index"
// 实际文件：src/views/system/menu/index.vue ✅
// 错误示例：src/views/system/menus/index.vue ❌
```

### Q3：如何调试动态路由？
**A：** 在控制台查看
```javascript
console.log(router.options.routes);
console.log(router.getRoutes());
```

---

## 9. 总结

### 当前项目状态
- ✅ 使用**静态路由**
- ✅ 菜单管理仅作为**记录功能**
- ✅ 权限控制在**前端硬编码**

### 完整动态路由的优势
- ✅ 菜单管理**实时生效**
- ✅ 权限**后端控制**
- ✅ 无需重新部署

### 实现建议
1. 如果需要灵活的权限控制 → 实现动态路由
2. 如果追求性能和简单性 → 保持静态路由
3. 混合方案：核心路由静态 + 业务路由动态
